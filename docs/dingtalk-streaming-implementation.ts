/**
 * DingTalk äº‹ä»¶æµå¤„ç†å®ç°å‚è€ƒ
 * 
 * ä» CoPaw å€Ÿé‰´çš„æ ¸å¿ƒæ€è·¯ï¼šå°†æµå¼äº‹ä»¶è½¬æ¢ä¸ºé€æ¡æ¶ˆæ¯å‘é€
 * 
 * @see dingtalk-event-streaming.md å®Œæ•´è®¾è®¡æ–‡æ¡£
 */

import type { Logger } from \"chat\";

// ============================================================================
// ç±»å‹å®šä¹‰
// ============================================================================

/** æµå¼äº‹ä»¶ç±»å‹ */\nexport interface StreamEvent {
  /** äº‹ä»¶å¯¹è±¡ç±»å‹ */\n  object: \"message\" | \"tool_call\" | \"tool_result\" | \"response\" | \"status\";
  /** äº‹ä»¶çŠ¶æ€ */\n  status: \"in_progress\" | \"completed\" | \"failed\";
  /** å†…å®¹ç±»å‹ */\n  type: \"text\" | \"tool_calls\" | \"function\" | \"image\" | \"file\";\n  /** äº‹ä»¶å†…å®¹ */\n  content: string;
  /** é¢å¤–å…ƒæ•°æ® */\n  metadata?: Record<string, unknown>;\n}\n\n/** æµå¼æ¶ˆæ¯é€‰é¡¹ */\nexport interface StreamMessageOptions {\n  /** æ˜¯å¦å¯ç”¨é€æ¡å‘é€ (é»˜è®¤ true) */\n  enableStepByStep?: boolean;\n  /** æ­¥éª¤é—´æœ€å°é—´éš” (ms) */\n  minStepInterval?: number;\n  /** æ˜¯å¦åŒ…å«å·¥å…·è°ƒç”¨è¯¦æƒ… */\n  showToolDetails?: boolean;\n}\n\n// ============================================================================\n// æ ¸å¿ƒå®ç°ï¼šé€æ¡å‘é€å¤„ç†å™¨\n// ============================================================================\n\nexport class StreamMessageHandler {\n  private lastSendTime = 0;\n  private stepCount = 0;\n\n  constructor(\n    private threadId: string,\n    private sendMessage: (text: string) => Promise<void>,\n    private options: StreamMessageOptions = {},\n    private logger?: Logger,\n  ) {\n    this.options = {\n      enableStepByStep: true,\n      minStepInterval: 300,\n      showToolDetails: true,\n      ...options,\n    };\n  }\n\n  /**\n   * å¤„ç†æµå¼äº‹ä»¶\n   * \n   * æ ¸å¿ƒé€»è¾‘ï¼š\n   * 1. è¿‡æ»¤ in_progress äº‹ä»¶ï¼ˆåªå¤„ç† completedï¼‰\n   * 2. æ¯ä¸ª completed äº‹ä»¶å‘é€ä¸€æ¡æ¶ˆæ¯\n   * 3. æ§åˆ¶å‘é€é¢‘ç‡é¿å…åˆ·å±\n   */\n  async handleEvent(event: StreamEvent): Promise<void> {\n    // åªå¤„ç†å·²å®Œæˆçš„äº‹ä»¶\n    if (event.status !== \"completed\") {\n      this.logger?.debug?.(\"Skipping in_progress event\", { type: event.type });\n      return;\n    }\n\n    // è¿‡æ»¤ç©ºå†…å®¹\n    if (!event.content?.trim()) {\n      return;\n    }\n\n    // æ§åˆ¶å‘é€é¢‘ç‡\n    const now = Date.now();\n    const timeSinceLastSend = now - this.lastSendTime;\n    const minInterval = this.options.minStepInterval ?? 300;\n\n    if (timeSinceLastSend < minInterval) {\n      await this.delay(minInterval - timeSinceLastSend);\n    }\n\n    // æ„å»ºæ¶ˆæ¯å†…å®¹\n    const message = this.formatMessage(event);\n    if (message) {\n      await this.sendMessage(message);\n      this.lastSendTime = Date.now();\n      this.stepCount++;\n    }\n  }\n\n  /**\n   * æ ¼å¼åŒ–æ¶ˆæ¯å†…å®¹\n   */\n  private formatMessage(event: StreamEvent): string | null {\n    switch (event.type) {\n      case \"text\":\n        return event.content;\n\n      case \"tool_calls\":\n        if (!this.options.showToolDetails) {\n          return null;\n        }\n        return `ğŸ”§ ${event.content}`;\n\n      case \"function\":\n        return event.content;\n\n      case \"image\":\n        return `[å›¾ç‰‡] ${event.content}`;\n\n      case \"file\":\n        return `[æ–‡ä»¶] ${event.content}`;\n\n      default:\n        return event.content;\n    }\n  }\n\n  /**\n   * å‘é€å®Œæˆæ€»ç»“\n   */\n  async sendCompletion(): Promise<void> {\n    if (this.stepCount > 1) {\n      await this.sendMessage(\"âœ… ä»»åŠ¡å®Œæˆ\");\n    }\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n// ============================================================================\n// Adapter é›†æˆç¤ºä¾‹\n// ============================================================================\n\n/**\n * åœ¨ DingTalkAdapter ä¸­é›†æˆæµå¼å¤„ç†\n * \n * å‚è€ƒ CoPaw: channel.py:1151-1210\n */\nexport class DingTalkAdapterStreamingExample {\n  /**\n   * æµå¼å‘é€æ¶ˆæ¯ï¼ˆé€æ¡å‘é€æ¨¡å¼ï¼‰\n   * \n   * é€‚ç”¨åœºæ™¯ï¼š\n   * - ç§èŠï¼ˆAI Card ä¸æ”¯æŒï¼‰\n   * - å¤šæ­¥éª¤ä»»åŠ¡éœ€è¦ä¸­é—´åé¦ˆ\n   * - ä¸éœ€è¦æ‰“å­—æœºæ•ˆæœçš„åœºæ™¯\n   */\n  async postMessageStream(\n    threadId: string,\n    stream: AsyncIterable<StreamEvent>,\n    options?: StreamMessageOptions,\n  ): Promise<void> {\n    const isGroup = this.isGroupThread(threadId);\n\n    // ç¾¤èŠä¼˜å…ˆä½¿ç”¨ AI Card\n    if (isGroup && this.config.cardTemplateId) {\n      return this.postMessageStreamWithAICard(threadId, stream);\n    }\n\n    // ç§èŠä½¿ç”¨é€æ¡å‘é€\n    return this.postMessageStreamStepByStep(threadId, stream, options);\n  }\n\n  /**\n   * é€æ¡å‘é€å®ç°ï¼ˆCoPaw æ¨¡å¼ï¼‰\n   */\n  private async postMessageStreamStepByStep(\n    threadId: string,\n    stream: AsyncIterable<StreamEvent>,\n    options?: StreamMessageOptions,\n  ): Promise<void> {\n    const handler = new StreamMessageHandler(\n      threadId,\n      async (text) => {\n        // ä½¿ç”¨ SessionWebhook æˆ– Proactive API å‘é€\n        await this.postMessage(threadId, { text });\n      },\n      options,\n      this.logger,\n    );\n\n    // å¤„ç†äº‹ä»¶æµï¼ˆå‚è€ƒ CoPaw çš„ async for å¾ªç¯ï¼‰\n    for await (const event of stream) {\n      await handler.handleEvent(event);\n    }\n\n    // å‘é€å®Œæˆæ ‡è®°\n    await handler.sendCompletion();\n  }\n\n  /**\n   * AI Card æµå¼å®ç°ï¼ˆç°æœ‰åŠŸèƒ½ï¼‰\n   */\n  private async postMessageStreamWithAICard(\n    threadId: string,\n    stream: AsyncIterable<StreamEvent>,\n  ): Promise<void> {\n    // åˆ›å»º AI Card\n    const card = await this.createAICard(threadId);\n    if (!card) {\n      // é™çº§åˆ°é€æ¡å‘é€\n      return this.postMessageStreamStepByStep(threadId, stream);\n    }\n\n    let fullContent = \"\";\n\n    for await (const event of stream) {\n      if (event.status === \"completed\" && event.type === \"text\") {\n        fullContent += event.content;\n        \n        // æµå¼æ›´æ–°å¡ç‰‡\n        await this.streamAICard(card, fullContent, false);\n      }\n    }\n\n    // å®Œæˆ\n    await this.streamAICard(card, fullContent, true);\n  }\n\n  // æ¨¡æ‹Ÿæ–¹æ³•\n  private isGroupThread(threadId: string): boolean {\n    return threadId.startsWith(\"group:\");\n  }\n\n  private async postMessage(\n    threadId: string,\n    message: { text: string },\n  ): Promise<void> {\n    // ç°æœ‰å®ç°\n  }\n\n  private async createAICard(threadId: string): Promise<unknown | null> {\n    // ç°æœ‰å®ç°\n    return null;\n  }\n\n  private async streamAICard(\n    card: unknown,\n    content: string,\n    isFinal: boolean,\n  ): Promise<void> {\n    // ç°æœ‰å®ç°\n  }\n\n  private config = { cardTemplateId: \"\" };\n  private logger?: Logger;\n}\n\n// ============================================================================\n// ä½¿ç”¨ç¤ºä¾‹\n// ============================================================================\n\n/**\n * åœ¨ Bot ä¸­ä½¿ç”¨çš„å®Œæ•´ç¤ºä¾‹\n */\nasync function exampleUsage() {\n  // å‡è®¾è¿™æ˜¯ä½ çš„ Chat SDK é›†æˆ\n  const adapter = new DingTalkAdapterStreamingExample();\n\n  // å¤„ç†ç”¨æˆ·æ¶ˆæ¯\n  async function handleUserMessage(\n    threadId: string,\n    userMessage: string,\n  ) {\n    // åˆ›å»ºäº‹ä»¶æµï¼ˆç”± Agent ç”Ÿæˆï¼‰\n    const eventStream = generateEventStream(userMessage);\n\n    // ä½¿ç”¨æµå¼å‘é€\n    await adapter.postMessageStream(threadId, eventStream, {\n      enableStepByStep: true,\n      minStepInterval: 500,  // æ¯æ¡æ¶ˆæ¯è‡³å°‘é—´éš” 500ms\n      showToolDetails: true, // æ˜¾ç¤ºå·¥å…·è°ƒç”¨\n    });\n  }\n\n  // æ¨¡æ‹Ÿ Agent äº‹ä»¶æµç”Ÿæˆ\n  async function* generateEventStream(\n    message: string,\n  ): AsyncGenerator<StreamEvent> {\n    // æ­¥éª¤ 1: æ€è€ƒä¸­\n    yield {\n      object: \"status\",\n      status: \"completed\",\n      type: \"text\",\n      content: \"ğŸ¤” æ­£åœ¨åˆ†æé—®é¢˜...\",\n    };\n\n    await delay(500);\n\n    // æ­¥éª¤ 2: å·¥å…·è°ƒç”¨\n    yield {\n      object: \"tool_call\",\n      status: \"completed\",\n      type: \"tool_calls\",\n      content: \"æ­£åœ¨æŸ¥è¯¢å¤©æ°”ä¿¡æ¯\",\n      metadata: { tool: \"weather\", location: \"åŒ—äº¬\" },\n    };\n\n    await delay(1000);\n\n    // æ­¥éª¤ 3: å·¥å…·ç»“æœ\n    yield {\n      object: \"tool_result\",\n      status: \"completed\",\n      type: \"text\",\n      content: \"åŒ—äº¬ä»Šå¤©å¤©æ°”æ™´æœ—ï¼Œæ°”æ¸© 15-25Â°C â˜€ï¸\",\n    };\n\n    await delay(500);\n\n    // æ­¥éª¤ 4: æœ€ç»ˆå›ç­”\n    yield {\n      object: \"message\",\n      status: \"completed\",\n      type: \"text\",\n      content: \"æ ¹æ®å¤©æ°”æƒ…å†µï¼Œå»ºè®®ç©¿è–„å¤–å¥—å‡ºé—¨ã€‚\",\n    };\n  }\n\n  function delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n// ============================================================================\n// ä¸ CoPaw çš„å¯¹æ¯”\n// ============================================================================\n\n/**\n * CoPaw (Python) vs yee88-chat-ai (TypeScript)\n * \n * CoPaw:\n * ```python\n * async for event in self._process(request):\n *     if obj == \"message\" and status == RunStatus.Completed:\n *         parts = self._message_to_content_parts(event)\n *         if use_multi and session_webhook:\n *             await self._send_via_session_webhook(session_webhook, body)\n * ```\n * \n * yee88-chat-ai (æœ¬å®ç°):\n * ```typescript\n * for await (const event of stream) {\n *     if (event.status === \"completed\") {\n *         await this.postMessage(threadId, { text: event.content });\n *     }\n * }\n * ```\n * \n * æ ¸å¿ƒæ€æƒ³ä¸€è‡´ï¼š\n * 1. éå†æµå¼äº‹ä»¶\n * 2. ç­›é€‰ completed çŠ¶æ€\n * 3. ç«‹å³å‘é€æ¶ˆæ¯\n * 4. æ”¯æŒå¤šåª’ä½“åˆ†å¼€å‘é€\n */